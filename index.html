<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Roblox Rivals Arena - Hidden Spawn</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="instructions">Click to play | WASD to move | SPACE to jump</div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    <script>
        // ===== GAME SETUP =====
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // SPAWN POSITION (behind left pillar)
        const spawnPosition = { x: -65, y: 5, z: -20 };
        camera.position.set(spawnPosition.x, spawnPosition.y, spawnPosition.z);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth / window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // ===== LIGHTING =====
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // ===== COLLISION SYSTEM =====
        const collidableObjects = [];
        const wallMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x444444,
            transparent: true,
            opacity: 0.7
        });

        // Player collider properties
        const playerCollider = {
            radius: 0.8,
            height: 1.8,
            position: new THREE.Vector3()
        };

        // ===== ARENA CONSTRUCTION =====
        const floorSize = 160; // Large arena size
        
        // Main floor
        const floor = new THREE.Mesh(
            new THREE.BoxGeometry(floorSize, 1, floorSize),
            new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.7 })
        );
        floor.position.y = -0.5;
        floor.receiveShadow = true;
        scene.add(floor);
        collidableObjects.push(floor);

        // Central big pillar
        const bigPillarSize = 20;
        const bigPillarHeight = 40;
        const bigPillar = new THREE.Mesh(
            new THREE.BoxGeometry(bigPillarSize, bigPillarHeight, bigPillarSize),
            wallMaterial
        );
        bigPillar.position.set(0, bigPillarHeight/2, 0);
        bigPillar.receiveShadow = true;
        scene.add(bigPillar);
        collidableObjects.push(bigPillar);

        // Platform on top of big pillar
        const bigPlatform = new THREE.Mesh(
            new THREE.BoxGeometry(bigPillarSize + 8, 2, bigPillarSize + 8),
            wallMaterial
        );
        bigPlatform.position.set(0, bigPillarHeight, 0);
        bigPlatform.receiveShadow = true;
        scene.add(bigPlatform);
        collidableObjects.push(bigPlatform);

        // Ramp to big pillar
        const bigPillarRamp = new THREE.Mesh(
            new THREE.BoxGeometry(16, 2, 24),
            wallMaterial
        );
        bigPillarRamp.position.set(0, bigPillarHeight/2 + 10, bigPillarSize/2 + 12);
        bigPillarRamp.rotation.x = -Math.PI/4;
        bigPillarRamp.receiveShadow = true;
        scene.add(bigPillarRamp);
        collidableObjects.push(bigPillarRamp);

        // Small pillars
        const smallPillarHeight = 20;
        const smallPillarSize = 12;
        const smallPillarPositions = [
            { x: -50, z: 0 }, // Left pillar
            { x: 50, z: 0 }    // Right pillar
        ];

        smallPillarPositions.forEach(pos => {
            // Small pillar
            const smallPillar = new THREE.Mesh(
                new THREE.BoxGeometry(smallPillarSize, smallPillarHeight, smallPillarSize),
                wallMaterial
            );
            smallPillar.position.set(pos.x, smallPillarHeight/2, pos.z);
            smallPillar.receiveShadow = true;
            scene.add(smallPillar);
            collidableObjects.push(smallPillar);

            // Platform on small pillar
            const smallPlatform = new THREE.Mesh(
                new THREE.BoxGeometry(smallPillarSize + 4, 2, smallPillarSize + 4),
                wallMaterial
            );
            smallPlatform.position.set(pos.x, smallPillarHeight, pos.z);
            smallPlatform.receiveShadow = true;
            scene.add(smallPlatform);
            collidableObjects.push(smallPlatform);

            // Ramp to small pillar
            const smallPillarRamp = new THREE.Mesh(
                new THREE.BoxGeometry(10, 2, 30),
                wallMaterial
            );
            smallPillarRamp.position.set(pos.x, smallPillarHeight/2 - 5, pos.z > 0 ? pos.z - 15 : pos.z + 15);
            smallPillarRamp.rotation.x = pos.z > 0 ? Math.PI/4 : -Math.PI/4;
            smallPillarRamp.receiveShadow = true;
            scene.add(smallPillarRamp);
            collidableObjects.push(smallPillarRamp);
        });

        // Boundary walls
        const wallHeight = 40;
        const wallGeometry = new THREE.BoxGeometry(floorSize, wallHeight, 2);
        
        for (let i = 0; i < 4; i++) {
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.y = wallHeight/2;
            
            switch(i) {
                case 0: wall.position.set(0, wall.position.y, -floorSize/2); break;
                case 1: wall.position.set(0, wall.position.y, floorSize/2); break;
                case 2: 
                    wall.rotation.y = Math.PI/2; 
                    wall.position.set(-floorSize/2, wall.position.y, 0); 
                    break;
                case 3: 
                    wall.rotation.y = Math.PI/2; 
                    wall.position.set(floorSize/2, wall.position.y, 0); 
                    break;
            }
            
            scene.add(wall);
            collidableObjects.push(wall);
        }

        // ===== PLAYER CONTROLS =====
        const controls = new THREE.PointerLockControls(camera, document.body);
        
        const movement = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false,
            isGrounded: false,
            velocityY: 0
        };
        
        // Key bindings
        const keysPressed = {};
        document.addEventListener('keydown', (e) => {
            keysPressed[e.code] = true;
            
            switch(e.code) {
                case 'KeyW': movement.forward = true; break;
                case 'KeyS': movement.backward = true; break;
                case 'KeyA': movement.left = true; break;
                case 'KeyD': movement.right = true; break;
                case 'Space': 
                    if (movement.isGrounded) {
                        movement.jump = true; 
                        movement.velocityY = 0.25;
                        movement.isGrounded = false;
                    }
                    break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keysPressed[e.code] = false;
            
            switch(e.code) {
                case 'KeyW': movement.forward = false; break;
                case 'KeyS': movement.backward = false; break;
                case 'KeyA': movement.left = false; break;
                case 'KeyD': movement.right = false; break;
                case 'Space': movement.jump = false; break;
            }
        });

        // Pointer lock controls
        document.addEventListener('click', () => {
            if (!controls.isLocked) {
                controls.lock();
                document.getElementById('instructions').style.display = 'none';
            }
        });

        // ===== COLLISION DETECTION =====
        function checkCollisions(newPos) {
            playerCollider.position.copy(newPos);
            
            for (const object of collidableObjects) {
                if (object.geometry.type === 'BoxGeometry') {
                    const boxSize = new THREE.Vector3();
                    object.geometry.computeBoundingBox();
                    object.geometry.boundingBox.getSize(boxSize);
                    
                    const boxPos = new THREE.Vector3();
                    object.getWorldPosition(boxPos);
                    
                    // AABB collision check
                    const xCollision = Math.abs(playerCollider.position.x - boxPos.x) < (boxSize.x/2 + playerCollider.radius);
                    const zCollision = Math.abs(playerCollider.position.z - boxPos.z) < (boxSize.z/2 + playerCollider.radius);
                    const yCollision = playerCollider.position.y < (boxPos.y + boxSize.y/2) && 
                                      playerCollider.position.y > (boxPos.y - boxSize.y/2);
                    
                    if (xCollision && zCollision && yCollision) {
                        return false; // Collision detected
                    }
                }
            }
            return true; // No collision
        }

        // Ground check
        function checkGrounded() {
            const feetPosition = new THREE.Vector3(
                camera.position.x,
                camera.position.y - playerCollider.height/2 - 0.1,
                camera.position.z
            );
            
            for (const object of collidableObjects) {
                if (object.geometry.type === 'BoxGeometry') {
                    const boxSize = new THREE.Vector3();
                    object.geometry.computeBoundingBox();
                    object.geometry.boundingBox.getSize(boxSize);
                    
                    const boxPos = new THREE.Vector3();
                    object.getWorldPosition(boxPos);
                    
                    const xInBounds = Math.abs(feetPosition.x - boxPos.x) < (boxSize.x/2 + playerCollider.radius);
                    const zInBounds = Math.abs(feetPosition.z - boxPos.z) < (boxSize.z/2 + playerCollider.radius);
                    const yOnSurface = Math.abs(feetPosition.y - (boxPos.y + boxSize.y/2)) < 0.5;
                    
                    if (xInBounds && zInBounds && yOnSurface) {
                        movement.isGrounded = true;
                        return;
                    }
                }
            }
            movement.isGrounded = false;
        }

        // ===== PHYSICS =====
        const gravity = 0.03;
        const moveSpeed = 0.2;

        // ===== GAME LOOP =====
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (controls.isLocked) {
                // Calculate movement direction
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();
                
                // Calculate movement vector
                const moveX = (movement.right ? moveSpeed : 0) + (movement.left ? -moveSpeed : 0);
                const moveZ = (movement.forward ? -moveSpeed : 0) + (movement.backward ? moveSpeed : 0);
                
                // Create new position for collision check
                const newPosition = new THREE.Vector3(
                    camera.position.x + moveX,
                    camera.position.y,
                    camera.position.z + moveZ
                );
                
                // Apply horizontal movement if no collision
                if (checkCollisions(newPosition)) {
                    camera.position.x = newPosition.x;
                    camera.position.z = newPosition.z;
                }
                
                // Apply gravity and jumping
                movement.velocityY -= gravity;
                
                // Vertical movement with collision check
                const newYPosition = camera.position.y + movement.velocityY;
                const verticalCheckPos = new THREE.Vector3(
                    camera.position.x,
                    newYPosition,
                    camera.position.z
                );
                
                if (checkCollisions(verticalCheckPos)) {
                    camera.position.y = newYPosition;
                } else {
                    movement.velocityY = 0;
                    if (movement.velocityY < 0) movement.isGrounded = true;
                }
                
                // Check if grounded
                checkGrounded();
                
                // Keep player in bounds
                const halfSize = floorSize/2 - 5;
                camera.position.x = Math.max(-halfSize, Math.min(halfSize, camera.position.x));
                camera.position.z = Math.max(-halfSize, Math.min(halfSize, camera.position.z));
            }
            
            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
