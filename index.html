<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Roblox Rivals Arena - Working Version</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="instructions">Click to play | WASD to move | SPACE to jump</div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    <script>
        // ===== GAME SETUP =====
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // Fixed spawn position (behind left pillar)
        camera.position.set(-65, 5, -20);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight); // Fixed this line
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // ===== LIGHTING =====
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // ===== ARENA CONSTRUCTION =====
        const floorSize = 160;
        const floorGeometry = new THREE.BoxGeometry(floorSize, 1, floorSize);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x555555,
            roughness: 0.7
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.position.y = -0.5;
        floor.receiveShadow = true;
        scene.add(floor);

        // Central big pillar
        const bigPillarSize = 20;
        const bigPillarHeight = 40;
        const bigPillar = new THREE.Mesh(
            new THREE.BoxGeometry(bigPillarSize, bigPillarHeight, bigPillarSize),
            new THREE.MeshStandardMaterial({ color: 0x888888 })
        );
        bigPillar.position.set(0, bigPillarHeight/2, 0);
        bigPillar.receiveShadow = true;
        scene.add(bigPillar);

        // ===== CONTROLS =====
        const controls = new THREE.PointerLockControls(camera, document.body);
        
        const movement = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false,
            isGrounded: true
        };
        
        // Key bindings
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': movement.forward = true; break;
                case 'KeyS': movement.backward = true; break;
                case 'KeyA': movement.left = true; break;
                case 'KeyD': movement.right = true; break;
                case 'Space': 
                    if (movement.isGrounded) {
                        movement.jump = true;
                        movement.isGrounded = false;
                    }
                    break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': movement.forward = false; break;
                case 'KeyS': movement.backward = false; break;
                case 'KeyA': movement.left = false; break;
                case 'KeyD': movement.right = false; break;
                case 'Space': movement.jump = false; break;
            }
        });

        // Pointer lock
        document.addEventListener('click', () => {
            if (!controls.isLocked) {
                controls.lock();
                document.getElementById('instructions').style.display = 'none';
            }
        });

        // ===== GAME LOOP =====
        const clock = new THREE.Clock();
        let velocityY = 0;
        const gravity = 0.03;
        const jumpForce = 0.15;
        const moveSpeed = 0.2;

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            
            if (controls.isLocked) {
                // Movement
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.y = 0;
                direction.normalize();
                
                const moveX = (movement.right ? moveSpeed : 0) + (movement.left ? -moveSpeed : 0);
                const moveZ = (movement.forward ? -moveSpeed : 0) + (movement.backward ? moveSpeed : 0);
                
                camera.position.x += moveX;
                camera.position.z += moveZ;
                
                // Jumping
                if (movement.jump && movement.isGrounded) {
                    velocityY = jumpForce;
                    movement.isGrounded = false;
                }
                
                // Gravity
                velocityY -= gravity;
                camera.position.y += velocityY;
                
                // Ground collision
                if (camera.position.y <= 5) {
                    camera.position.y = 5;
                    velocityY = 0;
                    movement.isGrounded = true;
                }
                
                // Boundary check
                const halfSize = floorSize/2 - 5;
                camera.position.x = Math.max(-halfSize, Math.min(halfSize, camera.position.x));
                camera.position.z = Math.max(-halfSize, Math.min(halfSize, camera.position.z));
            }
            
            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
