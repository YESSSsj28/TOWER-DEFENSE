<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Roblox Rivals Arena - Modified</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/PointerLockControls.js"></script>
    <script>
        // ===== GAME SETUP =====
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Sky blue background
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.y = 5;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // ===== LIGHTING =====
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(0, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        scene.add(directionalLight);

        // ===== ARENA CONSTRUCTION =====
        // Main floor (2x bigger)
        const floorSize = 80;
        const floorGeometry = new THREE.BoxGeometry(floorSize, 1, floorSize);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x555555,
            roughness: 0.7
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.position.y = -0.5;
        floor.receiveShadow = true;
        scene.add(floor);

        // Central big pillar
        const bigPillarSize = 10;
        const bigPillarHeight = 20;
        const bigPillarGeometry = new THREE.BoxGeometry(bigPillarSize, bigPillarHeight, bigPillarSize);
        const bigPillarMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const bigPillar = new THREE.Mesh(bigPillarGeometry, bigPillarMaterial);
        bigPillar.position.set(0, bigPillarHeight/2, 0);
        bigPillar.receiveShadow = true;
        scene.add(bigPillar);

        // Platform on top of big pillar
        const bigPillarPlatformGeometry = new THREE.BoxGeometry(bigPillarSize + 4, 1, bigPillarSize + 4);
        const bigPillarPlatform = new THREE.Mesh(bigPillarPlatformGeometry, bigPillarMaterial);
        bigPillarPlatform.position.set(0, bigPillarHeight, 0);
        bigPillarPlatform.receiveShadow = true;
        scene.add(bigPillarPlatform);

        // Small pillars (first jump)
        const smallPillarHeight = 10;
        const smallPillarSize = 6;
        const smallPillarGeometry = new THREE.BoxGeometry(smallPillarSize, smallPillarHeight, smallPillarSize);
        const smallPillarMaterial = new THREE.MeshStandardMaterial({ color: 0x777777 });

        // Create two small pillars (one on each side)
        const smallPillarPositions = [
            { x: -25, z: 0 },
            { x: 25, z: 0 }
        ];

        smallPillarPositions.forEach(pos => {
            const smallPillar = new THREE.Mesh(smallPillarGeometry, smallPillarMaterial);
            smallPillar.position.set(pos.x, smallPillarHeight/2, pos.z);
            smallPillar.receiveShadow = true;
            scene.add(smallPillar);

            // Platform on top of small pillar
            const smallPlatform = new THREE.Mesh(
                new THREE.BoxGeometry(smallPillarSize + 2, 1, smallPillarSize + 2),
                smallPillarMaterial
            );
            smallPlatform.position.set(pos.x, smallPillarHeight, pos.z);
            smallPlatform.receiveShadow = true;
            scene.add(smallPlatform);
        });

        // Spawn ramps (one on each side)
        const rampLength = 15;
        const rampGeometry = new THREE.BoxGeometry(5, 1, rampLength);
        const rampMaterial = new THREE.MeshStandardMaterial({ color: 0x666666 });

        const rampPositions = [
            { x: -30, z: 0, rotation: Math.PI/4 },
            { x: 30, z: 0, rotation: -Math.PI/4 }
        ];

        rampPositions.forEach(pos => {
            const ramp = new THREE.Mesh(rampGeometry, rampMaterial);
            ramp.position.set(pos.x, 2.5, pos.z);
            ramp.rotation.x = pos.rotation;
            ramp.receiveShadow = true;
            scene.add(ramp);
        });

        // Boundary walls
        const wallHeight = 20;
        const wallGeometry = new THREE.BoxGeometry(floorSize, wallHeight, 1);
        const wallMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x444444,
            transparent: true,
            opacity: 0.5
        });
        
        // Create 4 boundary walls
        for (let i = 0; i < 4; i++) {
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.y = wallHeight/2;
            
            switch(i) {
                case 0: wall.position.set(0, wall.position.y, -floorSize/2); break; // Front
                case 1: wall.position.set(0, wall.position.y, floorSize/2); break; // Back
                case 2: 
                    wall.rotation.y = Math.PI/2; 
                    wall.position.set(-floorSize/2, wall.position.y, 0); 
                    break; // Left
                case 3: 
                    wall.rotation.y = Math.PI/2; 
                    wall.position.set(floorSize/2, wall.position.y, 0); 
                    break; // Right
            }
            
            scene.add(wall);
        }

        // ===== PLAYER CONTROLS =====
        const controls = new THREE.PointerLockControls(camera, document.body);
        
        // Movement state
        const movement = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false,
            isGrounded: false
        };
        
        // Key bindings
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': movement.forward = true; break;
                case 'KeyS': movement.backward = true; break;
                case 'KeyA': movement.left = true; break;
                case 'KeyD': movement.right = true; break;
                case 'Space': movement.jump = true; break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': movement.forward = false; break;
                case 'KeyS': movement.backward = false; break;
                case 'KeyA': movement.left = false; break;
                case 'KeyD': movement.right = false; break;
                case 'Space': movement.jump = false; break;
            }
        });

        // Auto-lock pointer on click
        document.addEventListener('click', () => {
            controls.lock();
        });

        // ===== PHYSICS =====
        const gravity = 0.02;
        let velocityY = 0;
        const jumpForce = 0.2; // Increased jump force for platforming
        
        // Simple ground check
        function checkGrounded() {
            // Check if player is on ground or any platform
            movement.isGrounded = camera.position.y <= 5.1;
            
            // Check small pillars
            smallPillarPositions.forEach(pos => {
                if (Math.abs(camera.position.x - pos.x) < smallPillarSize/2 + 1 && 
                    Math.abs(camera.position.z - pos.z) < smallPillarSize/2 + 1 &&
                    Math.abs(camera.position.y - smallPillarHeight) < 1) {
                    movement.isGrounded = true;
                }
            });
            
            // Check big pillar
            if (Math.abs(camera.position.x) < bigPillarSize/2 + 1 && 
                Math.abs(camera.position.z) < bigPillarSize/2 + 1 &&
                Math.abs(camera.position.y - bigPillarHeight) < 1) {
                movement.isGrounded = true;
            }
        }

        // ===== GAME LOOP =====
        const clock = new THREE.Clock();
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            
            if (controls.isLocked) {
                // Movement
                const moveSpeed = 0.15;
                const moveX = (movement.right ? moveSpeed : 0) + (movement.left ? -moveSpeed : 0);
                const moveZ = (movement.forward ? -moveSpeed : 0) + (movement.backward ? moveSpeed : 0);
                
                // Apply movement
                camera.position.x += moveX;
                camera.position.z += moveZ;
                
                // Jumping
                checkGrounded();
                if (movement.jump && movement.isGrounded) {
                    velocityY = jumpForce;
                }
                
                // Apply gravity
                velocityY -= gravity;
                camera.position.y += velocityY;
                
                // Keep player in bounds
                const halfSize = floorSize/2 - 2;
                camera.position.x = Math.max(-halfSize, Math.min(halfSize, camera.position.x));
                camera.position.z = Math.max(-halfSize, Math.min(halfSize, camera.position.z));
                
                // Ground collision
                if (camera.position.y < 5 && movement.isGrounded) {
                    camera.position.y = 5;
                    velocityY = 0;
                }
            }
            
            renderer.render(scene, camera);
        }

        animate();

        // ===== WINDOW RESIZE =====
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
